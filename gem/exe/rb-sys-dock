#!/usr/bin/env ruby

require "optparse"
require "rb_sys/version"
require "rb_sys/toolchain_info"
require "fileutils"
require "tmpdir"

options = {
  version: RbSys::VERSION
}

def log(level, message, emoji: true, io: $stderr)
  emoji_opt, shellcode = case level
  when :error
    ["‚ùå", "\e[1;31m"]
  when :warn
    ["‚ö†Ô∏è", "\e[1;33m"]
  when :info
    ["‚ÑπÔ∏è", "\e[1;37m"]
  when :notice
    ["üê≥", "\e[1;34m"]
  when :trace
    return unless ENV["LOG_LEVEL"] == "trace"

    ["üîç", "\e[1;2m"]
  else raise "Unknown log level: #{level.inspect}"
  end

  emoji_opt = if emoji.is_a?(String)
    emoji + " "
  elsif emoji
    emoji_opt + " "
  end

  # Escape the message for bash shell codes (e.g. \e[1;31m)
  escaped = message.gsub("\\", "\\\\\\").gsub("\e", "\\e")

  io.puts "#{shellcode}#{emoji_opt}#{escaped}\e[0m"
end

def default_docker_command
  return @default_docker_command if defined?(@default_docker_command)

  @default_docker_command = ENV.fetch("DOCKER", "docker")
end

def run_command!(cmd)
  log(:trace, "Running command: $ #{cmd}")
  stdout, stderr, status = Open3.capture3(cmd)

  if status.success?
    stdout
  else
    log(:error, "Error running command: $ #{cmd}")
    warn(stderr)
    exit(status.exitstatus)
  end
end

def docker(cmd)
  require "open3"

  run_command!("#{default_docker_command} #{cmd}")
rescue Errno::ENOENT
  log(:trace, "Could not find docker command, trying podman")

  begin
    stdout = run_command!("podman #{cmd}")
    @default_docker_command = "podman"
    stdout
  rescue Errno::ENOENT
    log(:error, "Could not find docker or podman command, please install one of them")
    exit(1)
  end
end

OptionParser.new do |opts|
  opts.banner = "Usage: rb-sys-dock --platform PLATFORM [COMMAND]"

  opts.on("-v", "--version", "Prints version") do
    require "rb_sys/version"
    puts RbSys::VERSION
    exit
  end

  opts.on("-p", "--platform PLATFORM", "Platform to build for (i.e. x86_64-linux)") do |p|
    toolchain_info = begin
      RbSys::ToolchainInfo.new(p)
    rescue
      supported_list = RbSys::ToolchainInfo.all
      supported_list.select!(&:supported?)
      list = supported_list.map { |p| "- #{p} (#{p.rust_target})" }.join("\n")
      log(:error, "Platform #{p} is not supported, please use one of:\n\n#{list}")
      exit(1)
    end

    options[:platform] = p
    options[:toolchain_info] = toolchain_info
  end

  opts.on("--latest", "Use the latest version of the Docker image") do
    log(:notice, "Using latest version of the Docker image", emoji: "üÜï")
    options[:version] = "latest"
    options[:no_cache] = true
  end

  opts.on("--list-platforms", "--list", "List all supported platforms") do
    log(:notice, "Supported platforms listed below:")

    RbSys::ToolchainInfo.supported.each do |p|
      log(:info, "- #{p} (#{p.rust_target})", emoji: false, io: $stdout)
    end

    exit(0)
  end

  opts.on("--ruby-versions LIST", "List all supported Ruby versions") do |arg|
    log(:notice, "Requested Ruby versions: #{arg}")

    vers = arg.split(/[^0-9.]/).map do |v|
      parts = v.split(".")
      parts[2] = "0" if parts[2].nil?
      parts.join(".")
    end

    ENV["RUBY_CC_VERSION"] = vers.join(":")
  end

  opts.on("-h", "--help", "Prints this help") do
    puts opts
    exit
  end

  opts.on("-V", "--verbose", "Prints verbose output") do
    ENV["LOG_LEVEL"] = "trace"
    ENV["VERBOSE"] = "1"
    options[:verbose] = true
  end

  opts.on("--build", "Build the Docker image") do
    options[:build] = true
  end
end.parse!

def determine_cache_dir
  return ENV["RB_SYS_DOCK_CACHE_DIR"] if ENV["RB_SYS_DOCK_CACHE_DIR"]
  return File.join(ENV["XDG_CACHE_HOME"], "rb-sys-dock") if ENV["XDG_CACHE_HOME"]

  File.join(ENV["HOME"], ".cache", "rb-sys-dock")
end

def docker_tmp
  @docker_tmp ||= "/tmp/rb-sys-dock"
end

def cache_dir
  return @cache_dir if defined?(@cache_dir)

  @cache_dir = determine_cache_dir
  FileUtils.mkdir_p(@cache_dir)
  @cache_dir
end

def mount_cargo_registry
  local_registry_dir = if ENV["CARGO_HOME"]
    ENV["CARGO_HOME"]
  elsif File.exist?(cargo_home = File.join(ENV["HOME"], ".cargo"))
    cargo_home
  else
    File.join(cache_dir, "cargo")
  end

  dir = File.join("registry")
  log(:trace, "Mounting cargo registry dir: #{dir}")
  FileUtils.mkdir_p(dir)

  "--mount type=bind,source=#{File.join(local_registry_dir, dir)},target=#{File.join("/usr/local/cargo", dir)},readonly=false"
end

def volume(src, dest, mode: "rw")
  "--volume #{src}:#{dest}:rw"
end

def mount_bundle_cache(options)
  dir = File.join(cache_dir, options.fetch(:toolchain_info).platform, "bundle")
  bundle_path = File.join(docker_tmp, "bundle")
  FileUtils.mkdir_p(dir)
  log(:trace, "Mounting bundle cache: #{dir}")

  "#{volume(dir, bundle_path)} -e BUNDLE_PATH=#{bundle_path.inspect}"
end

def tmp_target_dir(options)
  return @tmp_target_dir if defined?(@tmp_target_dir)

  dir = File.join(Dir.pwd, "tmp", "rb-sys-dock", options.fetch(:toolchain_info).platform, "target")
  FileUtils.mkdir_p(dir)
  @tmp_target_dir = dir
end

def mount_target_dir(options)
  "-v #{tmp_target_dir(options)}:#{File.join(Dir.pwd, "target")}"
end

def mount_command_history(options)
  return unless $stdin.tty?

  history_dir = File.join(cache_dir, options.fetch(:platform), "commandhistory")
  FileUtils.mkdir_p(history_dir)
  "-v #{history_dir}:#{File.join(docker_tmp, "commandhistory")}"
end

def default_command_to_run(input_args, options)
  input_cmd = input_args.empty? ? "true" : input_args.join(" ")

  if options[:build]
    with_bundle = +"test -f Gemfile && bundle install && #{input_cmd} && bundle exec rake native:$RUBY_TARGET gem"
    without_bundle = "#{input_cmd} && rake native:$RUBY_TARGET gem"
    log(:notice, "Running default build command:")
    log(:notice, "    $ rake native:#{options[:toolchain_info].platform} gem")
    "bash -c '(#{with_bundle}) || (#{without_bundle})'"
  else
    input_args.empty? ? "bash" : "bash -c '#{input_args.join(" ")}'"
  end
end

def uid_gid
  if /darwin/.match?(RbConfig::CONFIG["host_os"])
    ["1000", "1000"]
  else
    [Process.uid, Process.gid]
  end
end

def user_mapping
  uid, gid = uid_gid
  "-e UID=#{uid} -e GID=#{gid} -e GROUP=_staff -e USER=rb-sys-dock"
end

def interactive?(input_args)
  $stdin.tty?
end

def mount_tmp_dir(options)
  "--mount type=bind,source=#{Dir.mktmpdir},destination=#{Dir.pwd}/tmp/#{options.fetch(:toolchain_info).platform},readonly=false"
end

def rcd(input_args, options)
  wrapper_command = []
  wrapper_command << "sigfw" unless interactive?(input_args)
  wrapper_command << "runas"

  docker_options = []
  docker_options << "--tty" if interactive?(input_args)

  cmd = <<~SH
    #{default_docker_command} run \
      -v #{Dir.pwd}:#{Dir.pwd} \
      #{mount_tmp_dir(options)} \
      #{mount_target_dir(options)} \
      #{mount_cargo_registry} \
      #{mount_bundle_cache(options)} \
      #{mount_command_history(options)} \
      #{user_mapping} \
      -e GEM_PRIVATE_KEY_PASSPHRASE \
      -e ftp_proxy \
      -e http_proxy \
      -e https_proxy \
      -e RCD_HOST_RUBY_PLATFORM=#{RbConfig::CONFIG["arch"]} \
      -e RCD_HOST_RUBY_VERSION=#{RUBY_VERSION} \
      -e RCD_IMAGE \
      -e RB_SYS_DOCK_TMPDIR="/tmp/rb-sys-dock" \
      -e RB_SYS_CARGO_TARGET_DIR=#{tmp_target_dir(options).inspect} \
      #{ENV["RUBY_CC_VERSION"] ? "-e RUBY_CC_VERSION=#{ENV["RUBY_CC_VERSION"]}" : ""} \
      -e RAKEOPT \
      -e TERM \
      -e LC_ALL=#{ENV.fetch("LC_ALL", "en_US.UTF-8")} \
      -w #{Dir.pwd} \
      --rm \
      --interactive \
      #{docker_options.join(" ")} \
      #{ENV.fetch("RCD_IMAGE")} \
      #{wrapper_command.join(" ")} \
      #{default_command_to_run(input_args, options)}
  SH

  log(:trace, "Running command: $ #{cmd}")

  exec(cmd)
end

def download_image(options)
  image = ENV.fetch("RCD_IMAGE")

  if docker("images -q #{image}").strip.empty? || options[:no_cache]
    # Nicely formatted message that we are downloading the image which might take awhile
    log(:notice, "Downloading container #{image.inspect}, this might take awhile...")
    docker("pull #{image} --quiet > /dev/null")
  end
end

def log_some_useful_info(_options)
  if ARGV.empty? && !options[:build]
    log(:notice, "Entering shell in Docker container #{ENV["RCD_IMAGE"].inspect}")
  else
    log(:notice, "Running command #{ARGV.inspect} in Docker container #{ENV["RCD_IMAGE"].inspect}")
  end
end

def set_env(options)
  ENV["RCD_IMAGE"] ||= "rbsys/#{options[:toolchain_info].platform}:#{options[:version]}"
end

set_env(options)
download_image(options)
log_some_useful_info(options)
rcd(ARGV, options)
